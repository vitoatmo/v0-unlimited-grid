"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/infinite-pannable-grid.tsx":
/*!***********************************************!*\
  !*** ./components/infinite-pannable-grid.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfinitePannableGrid: () => (/* binding */ InfinitePannableGrid)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _components_floating_grid_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/floating-grid-image */ \"(app-pages-browser)/./components/floating-grid-image.tsx\");\n/* __next_internal_client_entry_do_not_use__ InfinitePannableGrid auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst CELL_SIZE = 220;\nconst GRID_COLS = 5;\nconst VIEWPORT_BUFFER = 2;\nconst DRAG_THRESHOLD = 8; // px before we start panning\nfunction InfinitePannableGrid(param) {\n    let { images, panOffset, setPanOffset } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams)();\n    const paramString = searchParams === null || searchParams === void 0 ? void 0 : searchParams.toString();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isPanningRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const dragStart = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Center grid on mount ONLY if panOffset is {0,0}\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"InfinitePannableGrid.useEffect\": ()=>{\n            if (containerRef.current && panOffset.x === 0 && panOffset.y === 0) {\n                const { clientWidth, clientHeight } = containerRef.current;\n                setPanOffset({\n                    x: Math.round(clientWidth / 2),\n                    y: Math.round(clientHeight / 2)\n                });\n            }\n        // eslint-disable-next-line\n        }\n    }[\"InfinitePannableGrid.useEffect\"], []);\n    const getVisibleIndices = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[getVisibleIndices]\": ()=>{\n            if (!containerRef.current) return {\n                minRow: 0,\n                maxRow: 0,\n                minCol: 0,\n                maxCol: 0\n            };\n            const { clientWidth, clientHeight } = containerRef.current;\n            const minCol = Math.floor((-panOffset.x - VIEWPORT_BUFFER * CELL_SIZE) / CELL_SIZE);\n            const maxCol = Math.floor((-panOffset.x + clientWidth + VIEWPORT_BUFFER * CELL_SIZE) / CELL_SIZE);\n            const minRow = Math.floor((-panOffset.y - VIEWPORT_BUFFER * CELL_SIZE) / CELL_SIZE);\n            const maxRow = Math.floor((-panOffset.y + clientHeight + VIEWPORT_BUFFER * CELL_SIZE) / CELL_SIZE);\n            return {\n                minRow,\n                maxRow,\n                minCol,\n                maxCol\n            };\n        }\n    }[\"InfinitePannableGrid.useCallback[getVisibleIndices]\"], [\n        panOffset\n    ]);\n    // Only start panning if moved > threshold\n    const handlePointerDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerDown]\": (e)=>{\n            if (e.pointerType === \"mouse\" && e.button !== 0) return;\n            dragStart.current = {\n                x: e.clientX,\n                y: e.clientY,\n                panX: panOffset.x,\n                panY: panOffset.y\n            };\n            isPanningRef.current = false; // Not panning until moved enough\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerDown]\"], [\n        panOffset\n    ]);\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerMove]\": (e)=>{\n            if (!dragStart.current) return;\n            const dx = e.clientX - dragStart.current.x;\n            const dy = e.clientY - dragStart.current.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            if (!isPanningRef.current && distance > DRAG_THRESHOLD) {\n                isPanningRef.current = true;\n            }\n            if (isPanningRef.current) {\n                setPanOffset({\n                    x: dragStart.current.panX + dx,\n                    y: dragStart.current.panY + dy\n                });\n            }\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerMove]\"], [\n        setPanOffset\n    ]);\n    const handlePointerUp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerUp]\": ()=>{\n            dragStart.current = null;\n            isPanningRef.current = false;\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerUp]\"], []);\n    // Always pass params to detail page\n    const handleImageClick = (slug)=>{\n        const href = paramString ? \"/image/\".concat(slug, \"?\").concat(paramString) : \"/image/\".concat(slug);\n        router.push(href);\n    };\n    const renderedCells = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"InfinitePannableGrid.useMemo[renderedCells]\": ()=>{\n            if (images.length === 0) return [];\n            const { minRow, maxRow, minCol, maxCol } = getVisibleIndices();\n            const cells = [];\n            for(let row = minRow; row <= maxRow; row++){\n                for(let col = minCol; col <= maxCol; col++){\n                    const idx = Math.abs(row * GRID_COLS + col) % images.length;\n                    const img = images[idx];\n                    cells.push(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_floating_grid_image__WEBPACK_IMPORTED_MODULE_3__.FloatingGridImage, {\n                        src: img.imageUrl,\n                        alt: img.name,\n                        style: {\n                            transform: \"translate3d(\".concat(col * CELL_SIZE, \"px, \").concat(row * CELL_SIZE, \"px, 0px)\"),\n                            marginLeft: -100,\n                            marginTop: -100\n                        },\n                        onClick: {\n                            \"InfinitePannableGrid.useMemo[renderedCells]\": ()=>handleImageClick(img.slug)\n                        }[\"InfinitePannableGrid.useMemo[renderedCells]\"]\n                    }, \"\".concat(row, \",\").concat(col, \",\").concat(img.slug), false, {\n                        fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n                        lineNumber: 105,\n                        columnNumber: 11\n                    }, this));\n                }\n            }\n            return cells;\n        }\n    }[\"InfinitePannableGrid.useMemo[renderedCells]\"], [\n        images,\n        panOffset,\n        getVisibleIndices,\n        router,\n        paramString\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"fixed inset-0 overflow-hidden bg-gray-50 select-none\",\n        onPointerDown: handlePointerDown,\n        onPointerMove: handlePointerMove,\n        onPointerUp: handlePointerUp,\n        style: {\n            touchAction: \"none\",\n            cursor: isPanningRef.current ? \"grabbing\" : \"grab\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative\",\n            style: {\n                width: \"100vw\",\n                height: \"100vh\",\n                transform: \"translate3d(\".concat(panOffset.x, \"px, \").concat(panOffset.y, \"px, 0)\"),\n                willChange: isPanningRef.current ? \"transform\" : \"auto\"\n            },\n            children: renderedCells\n        }, void 0, false, {\n            fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n            lineNumber: 131,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n        lineNumber: 123,\n        columnNumber: 5\n    }, this);\n}\n_s(InfinitePannableGrid, \"o/0hUSMxoid/ReU9M1H1/CGC5vI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useSearchParams\n    ];\n});\n_c = InfinitePannableGrid;\nvar _c;\n$RefreshReg$(_c, \"InfinitePannableGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaW5maW5pdGUtcGFubmFibGUtZ3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFFZ0U7QUFDSDtBQUVRO0FBUXJFLE1BQU1PLFlBQVk7QUFDbEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMsaUJBQWlCLEdBQUcsNkJBQTZCO0FBRWhELFNBQVNDLHFCQUFxQixLQUlUO1FBSlMsRUFDbkNDLE1BQU0sRUFDTkMsU0FBUyxFQUNUQyxZQUFZLEVBQ2MsR0FKUzs7SUFLbkMsTUFBTUMsU0FBU1gsMERBQVNBO0lBQ3hCLE1BQU1ZLGVBQWVYLGdFQUFlQTtJQUNwQyxNQUFNWSxjQUFjRCx5QkFBQUEsbUNBQUFBLGFBQWNFLFFBQVE7SUFDMUMsTUFBTUMsZUFBZW5CLDZDQUFNQSxDQUFpQjtJQUU1QyxNQUFNb0IsZUFBZXBCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU1xQixZQUFZckIsNkNBQU1BLENBQThEO0lBRXRGLGtEQUFrRDtJQUNsREMsZ0RBQVNBOzBDQUFDO1lBQ1IsSUFBSWtCLGFBQWFHLE9BQU8sSUFBSVQsVUFBVVUsQ0FBQyxLQUFLLEtBQUtWLFVBQVVXLENBQUMsS0FBSyxHQUFHO2dCQUNsRSxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFLEdBQUdQLGFBQWFHLE9BQU87Z0JBQzFEUixhQUFhO29CQUNYUyxHQUFHSSxLQUFLQyxLQUFLLENBQUNILGNBQWM7b0JBQzVCRCxHQUFHRyxLQUFLQyxLQUFLLENBQUNGLGVBQWU7Z0JBQy9CO1lBQ0Y7UUFDQSwyQkFBMkI7UUFDN0I7eUNBQUcsRUFBRTtJQUVMLE1BQU1HLG9CQUFvQjNCLGtEQUFXQTsrREFBQztZQUNwQyxJQUFJLENBQUNpQixhQUFhRyxPQUFPLEVBQUUsT0FBTztnQkFBRVEsUUFBUTtnQkFBR0MsUUFBUTtnQkFBR0MsUUFBUTtnQkFBR0MsUUFBUTtZQUFFO1lBQy9FLE1BQU0sRUFBRVIsV0FB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b21wb25lbnRzL2luZmluaXRlLXBhbm5hYmxlLWdyaWQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciwgdXNlU2VhcmNoUGFyYW1zIH0gZnJvbSBcIm5leHQvbmF2aWdhdGlvblwiO1xuaW1wb3J0IHR5cGUgeyBJbWFnZUl0ZW0sIFBhblBvc2l0aW9uIH0gZnJvbSBcIkAvbGliL3R5cGVzXCI7XG5pbXBvcnQgeyBGbG9hdGluZ0dyaWRJbWFnZSB9IGZyb20gXCJAL2NvbXBvbmVudHMvZmxvYXRpbmctZ3JpZC1pbWFnZVwiO1xuXG5pbnRlcmZhY2UgSW5maW5pdGVQYW5uYWJsZUdyaWRQcm9wcyB7XG4gIGltYWdlczogSW1hZ2VJdGVtW107XG4gIHBhbk9mZnNldDogUGFuUG9zaXRpb247XG4gIHNldFBhbk9mZnNldDogKHBvczogUGFuUG9zaXRpb24pID0+IHZvaWQ7XG59XG5cbmNvbnN0IENFTExfU0laRSA9IDIyMDtcbmNvbnN0IEdSSURfQ09MUyA9IDU7XG5jb25zdCBWSUVXUE9SVF9CVUZGRVIgPSAyO1xuY29uc3QgRFJBR19USFJFU0hPTEQgPSA4OyAvLyBweCBiZWZvcmUgd2Ugc3RhcnQgcGFubmluZ1xuXG5leHBvcnQgZnVuY3Rpb24gSW5maW5pdGVQYW5uYWJsZUdyaWQoe1xuICBpbWFnZXMsXG4gIHBhbk9mZnNldCxcbiAgc2V0UGFuT2Zmc2V0LFxufTogSW5maW5pdGVQYW5uYWJsZUdyaWRQcm9wcykge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG4gIGNvbnN0IHBhcmFtU3RyaW5nID0gc2VhcmNoUGFyYW1zPy50b1N0cmluZygpO1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuXG4gIGNvbnN0IGlzUGFubmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRyYWdTdGFydCA9IHVzZVJlZjx7IHg6IG51bWJlcjsgeTogbnVtYmVyOyBwYW5YOiBudW1iZXI7IHBhblk6IG51bWJlciB9IHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gQ2VudGVyIGdyaWQgb24gbW91bnQgT05MWSBpZiBwYW5PZmZzZXQgaXMgezAsMH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQgJiYgcGFuT2Zmc2V0LnggPT09IDAgJiYgcGFuT2Zmc2V0LnkgPT09IDApIHtcbiAgICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICBzZXRQYW5PZmZzZXQoe1xuICAgICAgICB4OiBNYXRoLnJvdW5kKGNsaWVudFdpZHRoIC8gMiksXG4gICAgICAgIHk6IE1hdGgucm91bmQoY2xpZW50SGVpZ2h0IC8gMiksXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIH0sIFtdKTtcblxuICBjb25zdCBnZXRWaXNpYmxlSW5kaWNlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm4geyBtaW5Sb3c6IDAsIG1heFJvdzogMCwgbWluQ29sOiAwLCBtYXhDb2w6IDAgfTtcbiAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgfSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGNvbnN0IG1pbkNvbCA9IE1hdGguZmxvb3IoKC1wYW5PZmZzZXQueCAtIFZJRVdQT1JUX0JVRkZFUiAqIENFTExfU0laRSkgLyBDRUxMX1NJWkUpO1xuICAgIGNvbnN0IG1heENvbCA9IE1hdGguZmxvb3IoKC1wYW5PZmZzZXQueCArIGNsaWVudFdpZHRoICsgVklFV1BPUlRfQlVGRkVSICogQ0VMTF9TSVpFKSAvIENFTExfU0laRSk7XG4gICAgY29uc3QgbWluUm93ID0gTWF0aC5mbG9vcigoLXBhbk9mZnNldC55IC0gVklFV1BPUlRfQlVGRkVSICogQ0VMTF9TSVpFKSAvIENFTExfU0laRSk7XG4gICAgY29uc3QgbWF4Um93ID0gTWF0aC5mbG9vcigoLXBhbk9mZnNldC55ICsgY2xpZW50SGVpZ2h0ICsgVklFV1BPUlRfQlVGRkVSICogQ0VMTF9TSVpFKSAvIENFTExfU0laRSk7XG4gICAgcmV0dXJuIHsgbWluUm93LCBtYXhSb3csIG1pbkNvbCwgbWF4Q29sIH07XG4gIH0sIFtwYW5PZmZzZXRdKTtcblxuICAvLyBPbmx5IHN0YXJ0IHBhbm5pbmcgaWYgbW92ZWQgPiB0aHJlc2hvbGRcbiAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSB1c2VDYWxsYmFjaygoZTogUmVhY3QuUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwibW91c2VcIiAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgIGRyYWdTdGFydC5jdXJyZW50ID0ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgcGFuWDogcGFuT2Zmc2V0LngsXG4gICAgICBwYW5ZOiBwYW5PZmZzZXQueSxcbiAgICB9O1xuICAgIGlzUGFubmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7IC8vIE5vdCBwYW5uaW5nIHVudGlsIG1vdmVkIGVub3VnaFxuICB9LCBbcGFuT2Zmc2V0XSk7XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjaygoZTogUmVhY3QuUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgaWYgKCFkcmFnU3RhcnQuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGR4ID0gZS5jbGllbnRYIC0gZHJhZ1N0YXJ0LmN1cnJlbnQueDtcbiAgICBjb25zdCBkeSA9IGUuY2xpZW50WSAtIGRyYWdTdGFydC5jdXJyZW50Lnk7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKCFpc1Bhbm5pbmdSZWYuY3VycmVudCAmJiBkaXN0YW5jZSA+IERSQUdfVEhSRVNIT0xEKSB7XG4gICAgICBpc1Bhbm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc1Bhbm5pbmdSZWYuY3VycmVudCkge1xuICAgICAgc2V0UGFuT2Zmc2V0KHtcbiAgICAgICAgeDogZHJhZ1N0YXJ0LmN1cnJlbnQucGFuWCArIGR4LFxuICAgICAgICB5OiBkcmFnU3RhcnQuY3VycmVudC5wYW5ZICsgZHksXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtzZXRQYW5PZmZzZXRdKTtcblxuICBjb25zdCBoYW5kbGVQb2ludGVyVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZHJhZ1N0YXJ0LmN1cnJlbnQgPSBudWxsO1xuICAgIGlzUGFubmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtdKTtcblxuICAvLyBBbHdheXMgcGFzcyBwYXJhbXMgdG8gZGV0YWlsIHBhZ2VcbiAgY29uc3QgaGFuZGxlSW1hZ2VDbGljayA9IChzbHVnOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBocmVmID0gcGFyYW1TdHJpbmdcbiAgICAgID8gYC9pbWFnZS8ke3NsdWd9PyR7cGFyYW1TdHJpbmd9YFxuICAgICAgOiBgL2ltYWdlLyR7c2x1Z31gO1xuICAgIHJvdXRlci5wdXNoKGhyZWYpO1xuICB9O1xuXG4gIGNvbnN0IHJlbmRlcmVkQ2VsbHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHsgbWluUm93LCBtYXhSb3csIG1pbkNvbCwgbWF4Q29sIH0gPSBnZXRWaXNpYmxlSW5kaWNlcygpO1xuICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gbWluQ29sOyBjb2wgPD0gbWF4Q29sOyBjb2wrKykge1xuICAgICAgICBjb25zdCBpZHggPSBNYXRoLmFicygocm93ICogR1JJRF9DT0xTICsgY29sKSkgJSBpbWFnZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbWcgPSBpbWFnZXNbaWR4XTtcbiAgICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgICA8RmxvYXRpbmdHcmlkSW1hZ2VcbiAgICAgICAgICAgIGtleT17YCR7cm93fSwke2NvbH0sJHtpbWcuc2x1Z31gfVxuICAgICAgICAgICAgc3JjPXtpbWcuaW1hZ2VVcmx9XG4gICAgICAgICAgICBhbHQ9e2ltZy5uYW1lfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtjb2wgKiBDRUxMX1NJWkV9cHgsICR7cm93ICogQ0VMTF9TSVpFfXB4LCAwcHgpYCxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdDogLTEwMCxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wOiAtMTAwLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUltYWdlQ2xpY2soaW1nLnNsdWcpfVxuICAgICAgICAgIC8+XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjZWxscztcbiAgfSwgW2ltYWdlcywgcGFuT2Zmc2V0LCBnZXRWaXNpYmxlSW5kaWNlcywgcm91dGVyLCBwYXJhbVN0cmluZ10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICBjbGFzc05hbWU9e2BmaXhlZCBpbnNldC0wIG92ZXJmbG93LWhpZGRlbiBiZy1ncmF5LTUwIHNlbGVjdC1ub25lYH1cbiAgICAgIG9uUG9pbnRlckRvd249e2hhbmRsZVBvaW50ZXJEb3dufVxuICAgICAgb25Qb2ludGVyTW92ZT17aGFuZGxlUG9pbnRlck1vdmV9XG4gICAgICBvblBvaW50ZXJVcD17aGFuZGxlUG9pbnRlclVwfVxuICAgICAgc3R5bGU9e3sgdG91Y2hBY3Rpb246IFwibm9uZVwiLCBjdXJzb3I6IGlzUGFubmluZ1JlZi5jdXJyZW50ID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCIgfX1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogXCIxMDB2d1wiLFxuICAgICAgICAgIGhlaWdodDogXCIxMDB2aFwiLFxuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7cGFuT2Zmc2V0Lnh9cHgsICR7cGFuT2Zmc2V0Lnl9cHgsIDApYCxcbiAgICAgICAgICB3aWxsQ2hhbmdlOiBpc1Bhbm5pbmdSZWYuY3VycmVudCA/IFwidHJhbnNmb3JtXCIgOiBcImF1dG9cIixcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge3JlbmRlcmVkQ2VsbHN9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSb3V0ZXIiLCJ1c2VTZWFyY2hQYXJhbXMiLCJGbG9hdGluZ0dyaWRJbWFnZSIsIkNFTExfU0laRSIsIkdSSURfQ09MUyIsIlZJRVdQT1JUX0JVRkZFUiIsIkRSQUdfVEhSRVNIT0xEIiwiSW5maW5pdGVQYW5uYWJsZUdyaWQiLCJpbWFnZXMiLCJwYW5PZmZzZXQiLCJzZXRQYW5PZmZzZXQiLCJyb3V0ZXIiLCJzZWFyY2hQYXJhbXMiLCJwYXJhbVN0cmluZyIsInRvU3RyaW5nIiwiY29udGFpbmVyUmVmIiwiaXNQYW5uaW5nUmVmIiwiZHJhZ1N0YXJ0IiwiY3VycmVudCIsIngiLCJ5IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJNYXRoIiwicm91bmQiLCJnZXRWaXNpYmxlSW5kaWNlcyIsIm1pblJvdyIsIm1heFJvdyIsIm1pbkNvbCIsIm1heENvbCIsImZsb29yIiwiaGFuZGxlUG9pbnRlckRvd24iLCJlIiwicG9pbnRlclR5cGUiLCJidXR0b24iLCJjbGllbnRYIiwiY2xpZW50WSIsInBhblgiLCJwYW5ZIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJkeCIsImR5IiwiZGlzdGFuY2UiLCJzcXJ0IiwiaGFuZGxlUG9pbnRlclVwIiwiaGFuZGxlSW1hZ2VDbGljayIsInNsdWciLCJocmVmIiwicHVzaCIsInJlbmRlcmVkQ2VsbHMiLCJsZW5ndGgiLCJjZWxscyIsInJvdyIsImNvbCIsImlkeCIsImFicyIsImltZyIsInNyYyIsImltYWdlVXJsIiwiYWx0IiwibmFtZSIsInN0eWxlIiwidHJhbnNmb3JtIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsIm9uQ2xpY2siLCJkaXYiLCJyZWYiLCJjbGFzc05hbWUiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlclVwIiwidG91Y2hBY3Rpb24iLCJjdXJzb3IiLCJ3aWR0aCIsImhlaWdodCIsIndpbGxDaGFuZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/infinite-pannable-grid.tsx\n"));

/***/ })

});