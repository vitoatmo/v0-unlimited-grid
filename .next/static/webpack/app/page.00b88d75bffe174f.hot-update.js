"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/infinite-pannable-grid.tsx":
/*!***********************************************!*\
  !*** ./components/infinite-pannable-grid.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InfinitePannableGrid: () => (/* binding */ InfinitePannableGrid)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/utils */ \"(app-pages-browser)/./lib/utils.ts\");\n/* __next_internal_client_entry_do_not_use__ InfinitePannableGrid auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst CELL_SIZE = 250;\nconst VIEWPORT_BUFFER = 3;\nfunction getImageForCell(row, col, images) {\n    if (images.length === 0) return null;\n    const idx = Math.abs(row * 9973 + col * 7919) % images.length;\n    return images[idx];\n}\nfunction InfinitePannableGrid(param) {\n    let { images, searchQuery = \"\", selectedTag = null } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [isPanning, setIsPanning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [startPoint, setStartPoint] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [panOffset, setPanOffset] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 0,\n        y: 0\n    });\n    const [gridCells, setGridCells] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Map());\n    const panDistanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const pointerDownPos = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const clickedCellRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const CLICK_THRESHOLD = 8 // px\n    ;\n    // Calculate which grid cells should be visible based on pan offset\n    const getVisibleCellBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[getVisibleCellBounds]\": ()=>{\n            if (!containerRef.current) return {\n                minRow: 0,\n                maxRow: 0,\n                minCol: 0,\n                maxCol: 0\n            };\n            const { clientWidth, clientHeight } = containerRef.current;\n            const leftEdge = -panOffset.x - VIEWPORT_BUFFER * CELL_SIZE;\n            const rightEdge = -panOffset.x + clientWidth + VIEWPORT_BUFFER * CELL_SIZE;\n            const topEdge = -panOffset.y - VIEWPORT_BUFFER * CELL_SIZE;\n            const bottomEdge = -panOffset.y + clientHeight + VIEWPORT_BUFFER * CELL_SIZE;\n            const minCol = Math.floor(leftEdge / CELL_SIZE);\n            const maxCol = Math.ceil(rightEdge / CELL_SIZE);\n            const minRow = Math.floor(topEdge / CELL_SIZE);\n            const maxRow = Math.ceil(bottomEdge / CELL_SIZE);\n            return {\n                minRow,\n                maxRow,\n                minCol,\n                maxCol\n            };\n        }\n    }[\"InfinitePannableGrid.useCallback[getVisibleCellBounds]\"], [\n        panOffset\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"InfinitePannableGrid.useEffect\": ()=>{\n            if (images.length === 0) return;\n            const { minRow, maxRow, minCol, maxCol } = getVisibleCellBounds();\n            const newCells = new Map();\n            for(let row = minRow; row <= maxRow; row++){\n                for(let col = minCol; col <= maxCol; col++){\n                    const key = \"\".concat(row, \"-\").concat(col);\n                    const image = getImageForCell(row, col, images);\n                    if (image) {\n                        newCells.set(key, {\n                            id: \"\".concat(image.id, \"-\").concat(row, \"-\").concat(col),\n                            item: image,\n                            row,\n                            col\n                        });\n                    }\n                }\n            }\n            setGridCells(newCells);\n        }\n    }[\"InfinitePannableGrid.useEffect\"], [\n        images,\n        panOffset,\n        getVisibleCellBounds\n    ]);\n    // --- Gesture Handlers (panning + click detection) ---\n    const handlePointerDown = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerDown]\": (e)=>{\n            var _containerRef_current;\n            if (e.pointerType === \"mouse\" && e.button !== 0) return;\n            setIsPanning(true);\n            setStartPoint({\n                x: e.clientX - panOffset.x,\n                y: e.clientY - panOffset.y\n            });\n            pointerDownPos.current = {\n                x: e.clientX,\n                y: e.clientY\n            };\n            panDistanceRef.current = 0;\n            // Find which cell we start in\n            const rect = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.getBoundingClientRect();\n            if (rect) {\n                const x = e.clientX - rect.left - panOffset.x;\n                const y = e.clientY - rect.top - panOffset.y;\n                const col = Math.floor(x / CELL_SIZE);\n                const row = Math.floor(y / CELL_SIZE);\n                clickedCellRef.current = \"\".concat(row, \"-\").concat(col);\n            }\n            if (containerRef.current) {\n                containerRef.current.setPointerCapture(e.pointerId);\n            }\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerDown]\"], [\n        panOffset\n    ]);\n    const handlePointerMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerMove]\": (e)=>{\n            if (!isPanning) return;\n            const dx = e.clientX - pointerDownPos.current.x;\n            const dy = e.clientY - pointerDownPos.current.y;\n            panDistanceRef.current = Math.sqrt(dx * dx + dy * dy);\n            setPanOffset({\n                x: e.clientX - startPoint.x,\n                y: e.clientY - startPoint.y\n            });\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerMove]\"], [\n        isPanning,\n        startPoint\n    ]);\n    const handlePointerUp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"InfinitePannableGrid.useCallback[handlePointerUp]\": (e)=>{\n            setIsPanning(false);\n            if (containerRef.current) {\n                containerRef.current.releasePointerCapture(e.pointerId);\n            }\n            // Only treat as click if drag/pan distance is very small\n            if (panDistanceRef.current < CLICK_THRESHOLD && clickedCellRef.current) {\n                const cell = gridCells.get(clickedCellRef.current);\n                if (cell) {\n                    // preserve query params\n                    const params = new URLSearchParams();\n                    if (searchQuery) params.set(\"search\", searchQuery);\n                    if (selectedTag) params.set(\"tag\", selectedTag);\n                    const slug = cell.item.slug || (0,_lib_utils__WEBPACK_IMPORTED_MODULE_4__.slugify)(cell.item.name);\n                    router.push(\"/image/\".concat(slug).concat(params.toString() ? \"?\".concat(params) : \"\"));\n                }\n            }\n            clickedCellRef.current = null;\n        }\n    }[\"InfinitePannableGrid.useCallback[handlePointerUp]\"], [\n        gridCells,\n        searchQuery,\n        selectedTag,\n        router\n    ]);\n    // --- Render grid cells (NO box, only centered image) ---\n    const renderedCells = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"InfinitePannableGrid.useMemo[renderedCells]\": ()=>{\n            return Array.from(gridCells.values()).map({\n                \"InfinitePannableGrid.useMemo[renderedCells]\": (cell)=>{\n                    const isVisible = Math.abs(cell.col * CELL_SIZE + panOffset.x) < window.innerWidth + CELL_SIZE && Math.abs(cell.row * CELL_SIZE + panOffset.y) < window.innerHeight + CELL_SIZE;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"absolute flex items-center justify-center select-none transition-opacity duration-200\",\n                        style: {\n                            left: \"\".concat(cell.col * CELL_SIZE, \"px\"),\n                            top: \"\".concat(cell.row * CELL_SIZE, \"px\"),\n                            width: \"\".concat(CELL_SIZE, \"px\"),\n                            height: \"\".concat(CELL_SIZE, \"px\"),\n                            opacity: isVisible ? 1 : 0.7\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                            src: cell.item.imageUrl || \"/placeholder.svg\",\n                            alt: cell.item.name,\n                            fill: true,\n                            draggable: false,\n                            className: \"p-10 object-contain transition-transform duration-300 hover:scale-105\",\n                            sizes: \"250px\",\n                            loading: \"lazy\",\n                            placeholder: \"blur\",\n                            blurDataURL: \"data:image/jpeg;base64,/9j/...\"\n                        }, void 0, false, {\n                            fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n                            lineNumber: 167,\n                            columnNumber: 11\n                        }, this)\n                    }, cell.id, false, {\n                        fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n                        lineNumber: 155,\n                        columnNumber: 9\n                    }, this);\n                }\n            }[\"InfinitePannableGrid.useMemo[renderedCells]\"]);\n        }\n    }[\"InfinitePannableGrid.useMemo[renderedCells]\"], [\n        gridCells,\n        panOffset\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"fixed inset-0 overflow-hidden bg-white select-none \".concat(isPanning ? \"cursor-grabbing\" : \"cursor-grab\"),\n        onPointerDown: handlePointerDown,\n        onPointerMove: handlePointerMove,\n        onPointerUp: handlePointerUp,\n        style: {\n            touchAction: \"none\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative w-full h-full\",\n            style: {\n                transform: \"translate3d(\".concat(panOffset.x, \"px, \").concat(panOffset.y, \"px, 0)\"),\n                willChange: isPanning ? \"transform\" : \"auto\"\n            },\n            children: renderedCells\n        }, void 0, false, {\n            fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n            lineNumber: 192,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/vitoatmo/Documents/GitHub/v0-unlimited-grid/components/infinite-pannable-grid.tsx\",\n        lineNumber: 184,\n        columnNumber: 5\n    }, this);\n}\n_s(InfinitePannableGrid, \"xCPNPQrxJ5gD140EtVihwgU9pw8=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useRouter\n    ];\n});\n_c = InfinitePannableGrid;\nvar _c;\n$RefreshReg$(_c, \"InfinitePannableGrid\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaW5maW5pdGUtcGFubmFibGUtZ3JpZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRXlFO0FBQzNDO0FBQ2E7QUFFTjtBQWVyQyxNQUFNUSxZQUFZO0FBQ2xCLE1BQU1DLGtCQUFrQjtBQUV4QixTQUFTQyxnQkFBZ0JDLEdBQVcsRUFBRUMsR0FBVyxFQUFFQyxNQUFtQjtJQUNwRSxJQUFJQSxPQUFPQyxNQUFNLEtBQUssR0FBRyxPQUFPO0lBQ2hDLE1BQU1DLE1BQU1DLEtBQUtDLEdBQUcsQ0FBQ04sTUFBTSxPQUFPQyxNQUFNLFFBQVFDLE9BQU9DLE1BQU07SUFDN0QsT0FBT0QsTUFBTSxDQUFDRSxJQUFJO0FBQ3BCO0FBRU8sU0FBU0cscUJBQXFCLEtBSVQ7UUFKUyxFQUNuQ0wsTUFBTSxFQUNOTSxjQUFjLEVBQUUsRUFDaEJDLGNBQWMsSUFBSSxFQUNRLEdBSlM7O0lBS25DLE1BQU1DLFNBQVNmLDBEQUFTQTtJQUN4QixNQUFNZ0IsZUFBZXJCLDZDQUFNQSxDQUFpQjtJQUM1QyxNQUFNLENBQUNzQixXQUFXQyxhQUFhLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUN5QixZQUFZQyxjQUFjLEdBQUcxQiwrQ0FBUUEsQ0FBYztRQUFFMkIsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDdkUsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUc5QiwrQ0FBUUEsQ0FBYztRQUFFMkIsR0FBRztRQUFHQyxHQUFHO0lBQUU7SUFDckUsTUFBTSxDQUFDRyxXQUFXQyxhQUFhLEdBQUdoQywrQ0FBUUEsQ0FBd0IsSUFBSWlDO0lBQ3RFLE1BQU1DLGlCQUFpQmpDLDZDQUFNQSxDQUFDO0lBQzlCLE1BQU1rQyxpQkFBaUJsQyw2Q0FBTUEsQ0FBMkI7UUFBRTBCLEdBQUc7UUFBR0MsR0FBRztJQUFFO0lBQ3JFLE1BQU1RLGlCQUFpQm5DLDZDQUFNQSxDQUFnQjtJQUM3QyxNQUFNb0Msa0JBQWtCLEVB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MEYsU0FBU1QsWUFBWSxJQUFJO3dCQUUzQjtrQ0FFQSw0RUFBQ3BGLGtEQUFLQTs0QkFDSjhGLEtBQUt2QixLQUFLbkIsSUFBSSxDQUFDMkMsUUFBUSxJQUFJOzRCQUMzQkMsS0FBS3pCLEtBQUtuQixJQUFJLENBQUN3QixJQUFJOzRCQUNuQnFCLElBQUk7NEJBQ0pDLFdBQVc7NEJBQ1hULFdBQVU7NEJBQ1ZVLE9BQU07NEJBQ05DLFNBQVE7NEJBQ1JDLGFBQVk7NEJBQ1pDLGFBQVk7Ozs7Ozt1QkFwQlQvQixLQUFLcEIsRUFBRTs7Ozs7Z0JBd0JsQjs7UUFDRjtzREFBRztRQUFDekI7UUFBV0Y7S0FBVTtJQUV6QixxQkFDRSw4REFBQ2dFO1FBQ0NlLEtBQUt0RjtRQUNMd0UsV0FBVyxzREFBb0csT0FBOUN2RSxZQUFZLG9CQUFvQjtRQUNqR3NGLGVBQWVuRDtRQUNmb0QsZUFBZXhDO1FBQ2Z5QyxhQUFhckM7UUFDYnFCLE9BQU87WUFBRWlCLGFBQWE7UUFBTztrQkFFN0IsNEVBQUNuQjtZQUNDQyxXQUFVO1lBQ1ZDLE9BQU87Z0JBQ0xrQixXQUFXLGVBQWlDcEYsT0FBbEJBLFVBQVVGLENBQUMsRUFBQyxRQUFrQixPQUFaRSxVQUFVRCxDQUFDLEVBQUM7Z0JBQ3hEc0YsWUFBWTNGLFlBQVksY0FBYztZQUN4QztzQkFFQzZEOzs7Ozs7Ozs7OztBQUlUO0dBNUtnQmxFOztRQUtDWixzREFBU0E7OztLQUxWWSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpdG9hdG1vL0RvY3VtZW50cy9HaXRIdWIvdjAtdW5saW1pdGVkLWdyaWQvY29tcG9uZW50cy9pbmZpbml0ZS1wYW5uYWJsZS1ncmlkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCBJbWFnZSBmcm9tIFwibmV4dC9pbWFnZVwiXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCJcbmltcG9ydCB0eXBlIHsgSW1hZ2VJdGVtLCBQYW5Qb3NpdGlvbiB9IGZyb20gXCJAL2xpYi90eXBlc1wiXG5pbXBvcnQgeyBzbHVnaWZ5IH0gZnJvbSBcIkAvbGliL3V0aWxzXCJcblxuaW50ZXJmYWNlIEdyaWRDZWxsIHtcbiAgaWQ6IHN0cmluZ1xuICBpdGVtOiBJbWFnZUl0ZW1cbiAgcm93OiBudW1iZXJcbiAgY29sOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIEluZmluaXRlUGFubmFibGVHcmlkUHJvcHMge1xuICBpbWFnZXM6IEltYWdlSXRlbVtdXG4gIHNlYXJjaFF1ZXJ5Pzogc3RyaW5nXG4gIHNlbGVjdGVkVGFnPzogc3RyaW5nIHwgbnVsbFxufVxuXG5jb25zdCBDRUxMX1NJWkUgPSAyNTBcbmNvbnN0IFZJRVdQT1JUX0JVRkZFUiA9IDNcblxuZnVuY3Rpb24gZ2V0SW1hZ2VGb3JDZWxsKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaW1hZ2VzOiBJbWFnZUl0ZW1bXSkge1xuICBpZiAoaW1hZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcbiAgY29uc3QgaWR4ID0gTWF0aC5hYnMocm93ICogOTk3MyArIGNvbCAqIDc5MTkpICUgaW1hZ2VzLmxlbmd0aFxuICByZXR1cm4gaW1hZ2VzW2lkeF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEluZmluaXRlUGFubmFibGVHcmlkKHtcbiAgaW1hZ2VzLFxuICBzZWFyY2hRdWVyeSA9IFwiXCIsXG4gIHNlbGVjdGVkVGFnID0gbnVsbCxcbn06IEluZmluaXRlUGFubmFibGVHcmlkUHJvcHMpIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBbaXNQYW5uaW5nLCBzZXRJc1Bhbm5pbmddID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFtzdGFydFBvaW50LCBzZXRTdGFydFBvaW50XSA9IHVzZVN0YXRlPFBhblBvc2l0aW9uPih7IHg6IDAsIHk6IDAgfSlcbiAgY29uc3QgW3Bhbk9mZnNldCwgc2V0UGFuT2Zmc2V0XSA9IHVzZVN0YXRlPFBhblBvc2l0aW9uPih7IHg6IDAsIHk6IDAgfSlcbiAgY29uc3QgW2dyaWRDZWxscywgc2V0R3JpZENlbGxzXSA9IHVzZVN0YXRlPE1hcDxzdHJpbmcsIEdyaWRDZWxsPj4obmV3IE1hcCgpKVxuICBjb25zdCBwYW5EaXN0YW5jZVJlZiA9IHVzZVJlZigwKVxuICBjb25zdCBwb2ludGVyRG93blBvcyA9IHVzZVJlZjx7IHg6IG51bWJlciwgeTogbnVtYmVyIH0+KHsgeDogMCwgeTogMCB9KVxuICBjb25zdCBjbGlja2VkQ2VsbFJlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBDTElDS19USFJFU0hPTEQgPSA4IC8vIHB4XG5cbiAgLy8gQ2FsY3VsYXRlIHdoaWNoIGdyaWQgY2VsbHMgc2hvdWxkIGJlIHZpc2libGUgYmFzZWQgb24gcGFuIG9mZnNldFxuICBjb25zdCBnZXRWaXNpYmxlQ2VsbEJvdW5kcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm4geyBtaW5Sb3c6IDAsIG1heFJvdzogMCwgbWluQ29sOiAwLCBtYXhDb2w6IDAgfVxuICAgIGNvbnN0IHsgY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCB9ID0gY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICBjb25zdCBsZWZ0RWRnZSA9IC1wYW5PZmZzZXQueCAtIFZJRVdQT1JUX0JVRkZFUiAqIENFTExfU0laRVxuICAgIGNvbnN0IHJpZ2h0RWRnZSA9IC1wYW5PZmZzZXQueCArIGNsaWVudFdpZHRoICsgVklFV1BPUlRfQlVGRkVSICogQ0VMTF9TSVpFXG4gICAgY29uc3QgdG9wRWRnZSA9IC1wYW5PZmZzZXQueSAtIFZJRVdQT1JUX0JVRkZFUiAqIENFTExfU0laRVxuICAgIGNvbnN0IGJvdHRvbUVkZ2UgPSAtcGFuT2Zmc2V0LnkgKyBjbGllbnRIZWlnaHQgKyBWSUVXUE9SVF9CVUZGRVIgKiBDRUxMX1NJWkVcbiAgICBjb25zdCBtaW5Db2wgPSBNYXRoLmZsb29yKGxlZnRFZGdlIC8gQ0VMTF9TSVpFKVxuICAgIGNvbnN0IG1heENvbCA9IE1hdGguY2VpbChyaWdodEVkZ2UgLyBDRUxMX1NJWkUpXG4gICAgY29uc3QgbWluUm93ID0gTWF0aC5mbG9vcih0b3BFZGdlIC8gQ0VMTF9TSVpFKVxuICAgIGNvbnN0IG1heFJvdyA9IE1hdGguY2VpbChib3R0b21FZGdlIC8gQ0VMTF9TSVpFKVxuICAgIHJldHVybiB7IG1pblJvdywgbWF4Um93LCBtaW5Db2wsIG1heENvbCB9XG4gIH0sIFtwYW5PZmZzZXRdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGNvbnN0IHsgbWluUm93LCBtYXhSb3csIG1pbkNvbCwgbWF4Q29sIH0gPSBnZXRWaXNpYmxlQ2VsbEJvdW5kcygpXG4gICAgY29uc3QgbmV3Q2VsbHMgPSBuZXcgTWFwPHN0cmluZywgR3JpZENlbGw+KClcbiAgICBmb3IgKGxldCByb3cgPSBtaW5Sb3c7IHJvdyA8PSBtYXhSb3c7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSBtaW5Db2w7IGNvbCA8PSBtYXhDb2w7IGNvbCsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3Jvd30tJHtjb2x9YFxuICAgICAgICBjb25zdCBpbWFnZSA9IGdldEltYWdlRm9yQ2VsbChyb3csIGNvbCwgaW1hZ2VzKVxuICAgICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgICBuZXdDZWxscy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBpZDogYCR7aW1hZ2UuaWR9LSR7cm93fS0ke2NvbH1gLFxuICAgICAgICAgICAgaXRlbTogaW1hZ2UsXG4gICAgICAgICAgICByb3csXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZXRHcmlkQ2VsbHMobmV3Q2VsbHMpXG4gIH0sIFtpbWFnZXMsIHBhbk9mZnNldCwgZ2V0VmlzaWJsZUNlbGxCb3VuZHNdKVxuXG4gIC8vIC0tLSBHZXN0dXJlIEhhbmRsZXJzIChwYW5uaW5nICsgY2xpY2sgZGV0ZWN0aW9uKSAtLS1cbiAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSB1c2VDYWxsYmFjayhcbiAgICAoZTogUmVhY3QuUG9pbnRlckV2ZW50KSA9PiB7XG4gICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiICYmIGUuYnV0dG9uICE9PSAwKSByZXR1cm5cbiAgICAgIHNldElzUGFubmluZyh0cnVlKVxuICAgICAgc2V0U3RhcnRQb2ludCh7XG4gICAgICAgIHg6IGUuY2xpZW50WCAtIHBhbk9mZnNldC54LFxuICAgICAgICB5OiBlLmNsaWVudFkgLSBwYW5PZmZzZXQueSxcbiAgICAgIH0pXG4gICAgICBwb2ludGVyRG93blBvcy5jdXJyZW50ID0geyB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WSB9XG4gICAgICBwYW5EaXN0YW5jZVJlZi5jdXJyZW50ID0gMFxuXG4gICAgICAvLyBGaW5kIHdoaWNoIGNlbGwgd2Ugc3RhcnQgaW5cbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXJSZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBwYW5PZmZzZXQueFxuICAgICAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3AgLSBwYW5PZmZzZXQueVxuICAgICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKHggLyBDRUxMX1NJWkUpXG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoeSAvIENFTExfU0laRSlcbiAgICAgICAgY2xpY2tlZENlbGxSZWYuY3VycmVudCA9IGAke3Jvd30tJHtjb2x9YFxuICAgICAgfVxuICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKVxuICAgICAgfVxuICAgIH0sXG4gICAgW3Bhbk9mZnNldF0sXG4gIClcblxuICBjb25zdCBoYW5kbGVQb2ludGVyTW92ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5Qb2ludGVyRXZlbnQpID0+IHtcbiAgICAgIGlmICghaXNQYW5uaW5nKSByZXR1cm5cbiAgICAgIGNvbnN0IGR4ID0gZS5jbGllbnRYIC0gcG9pbnRlckRvd25Qb3MuY3VycmVudC54XG4gICAgICBjb25zdCBkeSA9IGUuY2xpZW50WSAtIHBvaW50ZXJEb3duUG9zLmN1cnJlbnQueVxuICAgICAgcGFuRGlzdGFuY2VSZWYuY3VycmVudCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbiAgICAgIHNldFBhbk9mZnNldCh7XG4gICAgICAgIHg6IGUuY2xpZW50WCAtIHN0YXJ0UG9pbnQueCxcbiAgICAgICAgeTogZS5jbGllbnRZIC0gc3RhcnRQb2ludC55LFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtpc1Bhbm5pbmcsIHN0YXJ0UG9pbnRdLFxuICApXG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlclVwID0gdXNlQ2FsbGJhY2soXG4gICAgKGU6IFJlYWN0LlBvaW50ZXJFdmVudCkgPT4ge1xuICAgICAgc2V0SXNQYW5uaW5nKGZhbHNlKVxuICAgICAgaWYgKGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZClcbiAgICAgIH1cbiAgICAgIC8vIE9ubHkgdHJlYXQgYXMgY2xpY2sgaWYgZHJhZy9wYW4gZGlzdGFuY2UgaXMgdmVyeSBzbWFsbFxuICAgICAgaWYgKHBhbkRpc3RhbmNlUmVmLmN1cnJlbnQgPCBDTElDS19USFJFU0hPTEQgJiYgY2xpY2tlZENlbGxSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBjZWxsID0gZ3JpZENlbGxzLmdldChjbGlja2VkQ2VsbFJlZi5jdXJyZW50KVxuICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgIC8vIHByZXNlcnZlIHF1ZXJ5IHBhcmFtc1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICAgICAgICAgIGlmIChzZWFyY2hRdWVyeSkgcGFyYW1zLnNldChcInNlYXJjaFwiLCBzZWFyY2hRdWVyeSlcbiAgICAgICAgICBpZiAoc2VsZWN0ZWRUYWcpIHBhcmFtcy5zZXQoXCJ0YWdcIiwgc2VsZWN0ZWRUYWcpXG4gICAgICAgICAgY29uc3Qgc2x1ZyA9IGNlbGwuaXRlbS5zbHVnIHx8IHNsdWdpZnkoY2VsbC5pdGVtLm5hbWUpXG4gICAgICAgICAgcm91dGVyLnB1c2goYC9pbWFnZS8ke3NsdWd9JHtwYXJhbXMudG9TdHJpbmcoKSA/IGA/JHtwYXJhbXN9YCA6IFwiXCJ9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2xpY2tlZENlbGxSZWYuY3VycmVudCA9IG51bGxcbiAgICB9LFxuICAgIFtncmlkQ2VsbHMsIHNlYXJjaFF1ZXJ5LCBzZWxlY3RlZFRhZywgcm91dGVyXSxcbiAgKVxuXG4gIC8vIC0tLSBSZW5kZXIgZ3JpZCBjZWxscyAoTk8gYm94LCBvbmx5IGNlbnRlcmVkIGltYWdlKSAtLS1cbiAgY29uc3QgcmVuZGVyZWRDZWxscyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdyaWRDZWxscy52YWx1ZXMoKSkubWFwKChjZWxsKSA9PiB7XG4gICAgICBjb25zdCBpc1Zpc2libGUgPVxuICAgICAgICBNYXRoLmFicyhjZWxsLmNvbCAqIENFTExfU0laRSArIHBhbk9mZnNldC54KSA8IHdpbmRvdy5pbm5lcldpZHRoICsgQ0VMTF9TSVpFICYmXG4gICAgICAgIE1hdGguYWJzKGNlbGwucm93ICogQ0VMTF9TSVpFICsgcGFuT2Zmc2V0LnkpIDwgd2luZG93LmlubmVySGVpZ2h0ICsgQ0VMTF9TSVpFXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAga2V5PXtjZWxsLmlkfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHNlbGVjdC1ub25lIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0yMDBcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBsZWZ0OiBgJHtjZWxsLmNvbCAqIENFTExfU0laRX1weGAsXG4gICAgICAgICAgICB0b3A6IGAke2NlbGwucm93ICogQ0VMTF9TSVpFfXB4YCxcbiAgICAgICAgICAgIHdpZHRoOiBgJHtDRUxMX1NJWkV9cHhgLFxuICAgICAgICAgICAgaGVpZ2h0OiBgJHtDRUxMX1NJWkV9cHhgLFxuICAgICAgICAgICAgb3BhY2l0eTogaXNWaXNpYmxlID8gMSA6IDAuNyxcbiAgICAgICAgICAgIC8vIE5vIGJnLCBubyBib3JkZXIsIHNlYW1sZXNzIVxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgIHNyYz17Y2VsbC5pdGVtLmltYWdlVXJsIHx8IFwiL3BsYWNlaG9sZGVyLnN2Z1wifVxuICAgICAgICAgICAgYWx0PXtjZWxsLml0ZW0ubmFtZX1cbiAgICAgICAgICAgIGZpbGxcbiAgICAgICAgICAgIGRyYWdnYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJwLTEwIG9iamVjdC1jb250YWluIHRyYW5zaXRpb24tdHJhbnNmb3JtIGR1cmF0aW9uLTMwMCBob3ZlcjpzY2FsZS0xMDVcIlxuICAgICAgICAgICAgc2l6ZXM9XCIyNTBweFwiXG4gICAgICAgICAgICBsb2FkaW5nPVwibGF6eVwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cImJsdXJcIlxuICAgICAgICAgICAgYmx1ckRhdGFVUkw9XCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai8uLi5cIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKVxuICAgIH0pXG4gIH0sIFtncmlkQ2VsbHMsIHBhbk9mZnNldF0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIGNsYXNzTmFtZT17YGZpeGVkIGluc2V0LTAgb3ZlcmZsb3ctaGlkZGVuIGJnLXdoaXRlIHNlbGVjdC1ub25lICR7aXNQYW5uaW5nID8gXCJjdXJzb3ItZ3JhYmJpbmdcIiA6IFwiY3Vyc29yLWdyYWJcIn1gfVxuICAgICAgb25Qb2ludGVyRG93bj17aGFuZGxlUG9pbnRlckRvd259XG4gICAgICBvblBvaW50ZXJNb3ZlPXtoYW5kbGVQb2ludGVyTW92ZX1cbiAgICAgIG9uUG9pbnRlclVwPXtoYW5kbGVQb2ludGVyVXB9XG4gICAgICBzdHlsZT17eyB0b3VjaEFjdGlvbjogXCJub25lXCIgfX1cbiAgICA+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cInJlbGF0aXZlIHctZnVsbCBoLWZ1bGxcIlxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7cGFuT2Zmc2V0Lnh9cHgsICR7cGFuT2Zmc2V0Lnl9cHgsIDApYCxcbiAgICAgICAgICB3aWxsQ2hhbmdlOiBpc1Bhbm5pbmcgPyBcInRyYW5zZm9ybVwiIDogXCJhdXRvXCIsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtyZW5kZXJlZENlbGxzfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsIkltYWdlIiwidXNlUm91dGVyIiwic2x1Z2lmeSIsIkNFTExfU0laRSIsIlZJRVdQT1JUX0JVRkZFUiIsImdldEltYWdlRm9yQ2VsbCIsInJvdyIsImNvbCIsImltYWdlcyIsImxlbmd0aCIsImlkeCIsIk1hdGgiLCJhYnMiLCJJbmZpbml0ZVBhbm5hYmxlR3JpZCIsInNlYXJjaFF1ZXJ5Iiwic2VsZWN0ZWRUYWciLCJyb3V0ZXIiLCJjb250YWluZXJSZWYiLCJpc1Bhbm5pbmciLCJzZXRJc1Bhbm5pbmciLCJzdGFydFBvaW50Iiwic2V0U3RhcnRQb2ludCIsIngiLCJ5IiwicGFuT2Zmc2V0Iiwic2V0UGFuT2Zmc2V0IiwiZ3JpZENlbGxzIiwic2V0R3JpZENlbGxzIiwiTWFwIiwicGFuRGlzdGFuY2VSZWYiLCJwb2ludGVyRG93blBvcyIsImNsaWNrZWRDZWxsUmVmIiwiQ0xJQ0tfVEhSRVNIT0xEIiwiZ2V0VmlzaWJsZUNlbGxCb3VuZHMiLCJjdXJyZW50IiwibWluUm93IiwibWF4Um93IiwibWluQ29sIiwibWF4Q29sIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJsZWZ0RWRnZSIsInJpZ2h0RWRnZSIsInRvcEVkZ2UiLCJib3R0b21FZGdlIiwiZmxvb3IiLCJjZWlsIiwibmV3Q2VsbHMiLCJrZXkiLCJpbWFnZSIsInNldCIsImlkIiwiaXRlbSIsImhhbmRsZVBvaW50ZXJEb3duIiwiZSIsInBvaW50ZXJUeXBlIiwiYnV0dG9uIiwiY2xpZW50WCIsImNsaWVudFkiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVmdCIsInRvcCIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJkeCIsImR5Iiwic3FydCIsImhhbmRsZVBvaW50ZXJVcCIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsImNlbGwiLCJnZXQiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzbHVnIiwibmFtZSIsInB1c2giLCJ0b1N0cmluZyIsInJlbmRlcmVkQ2VsbHMiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJtYXAiLCJpc1Zpc2libGUiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJkaXYiLCJjbGFzc05hbWUiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0Iiwib3BhY2l0eSIsInNyYyIsImltYWdlVXJsIiwiYWx0IiwiZmlsbCIsImRyYWdnYWJsZSIsInNpemVzIiwibG9hZGluZyIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJyZWYiLCJvblBvaW50ZXJEb3duIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlclVwIiwidG91Y2hBY3Rpb24iLCJ0cmFuc2Zvcm0iLCJ3aWxsQ2hhbmdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/infinite-pannable-grid.tsx\n"));

/***/ })

});